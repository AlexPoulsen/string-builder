/**
 * An StringBuilder implementation in kit.
 * @author Tyler Bezera
 * @author Alex Poulsen
 */

import xs_Rounding;
include "math.h";

/**
 * Not necessarily needed for the StringBuilder, but it's a useful function that works well for appending strings in a situation where a StringBuilder is not necessary
 */
function strAdd(one: CString, two: CString) {
    var out = malloc(one.length + two.length + 1);
    strcpy(out, one);
    strcat(out, two);
    return out;
}


struct StringBuilder {
    private var chars: Ptr[Char];
    private var length: Int;
    private var allocated: Int;


    public static function new(): StringBuilder {
        return struct Self {
            chars: *(malloc(20*sizeof(Char))): Ptr[Char],
            length: 0,
            allocated: 20
        };
    }


    public static function newFromString(initialize: CString): StringBuilder {
        var initSize: Int = 20;
        if initialize.length > initSize {
            initSize = initialize.length;
        }
        initSize *= 2;
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        strcpy(initChars, initialize);
        return struct Self {
            chars: initChars,
            length: initialize.length,
            allocated: initSize
        };
    }


    public static function newFromInt(initialize: Int): StringBuilder {
        var numSize: Int = xs_CeilToInt(log10(initialize: Float64));  // for numbers like 1000000000, it will report the length as one less than it is. this is fixed by multiplying the initSize by 2.
        printf("numSize: %d\n", numSize);
        printf("log10: %f\n", log10(initialize: Float64));
        printf("initialize: %d\n", initialize);
        var initSize: Int = 20;
        if numSize > initSize {
            initSize = numSize;
        }
        initSize *= 2;
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        sprintf(initChars,"%d", initialize);
        return struct Self {
            chars: initChars,
            length: numSize,
            allocated: initSize
        };
    }

    public function getLen(): Void {
        printf("length: %d\n", this.length);
        printf("allocated: %d\n", this.allocated);
    }

    public function toString(): CString {
        var out: CString = malloc((this.length + 1) * sizeof(CString));
        strcpy(out, this.chars);
        return out;
    }

    public function appendString(append: CString): Void {
        this.ensureSpace(append.length);
        strcat(this.chars, append);
    }

    public function appendInt(append: Int): Void {
        var numSize: Int = xs_CeilToInt(log10(append: Float64)) + 1;  // for numbers like 1000000000, log10 will report the length as one less than it is.
        var initChars: Ptr[Char] = *(malloc(numSize*sizeof(Char))): Ptr[Char];
        sprintf(initChars,"%d", append);
        this.ensureSpace(numSize+1);
        strcat(this.chars, initChars);
    }

    public function ensureSpace(addLen: Int): Void {
        printf("Begin\n");
        if addLen == 0 {
            return;
        }
        printf("After first if\n");
        if (this.allocated >= this.length + addLen + 1) {
            return;
        }
        var stopIter = 0;
        printf("After second if\n");
        printf("While begin\n");
        while (this.allocated < this.length + addLen + 1) {
            /* Doubling growth strategy. */
            printf("begin %d < %d + %d\n", this.allocated, this.length, addLen);
            this.allocated <<= 1;
            if (this.allocated == 0) {
                printf("if begin %d < %d + %d\n", this.allocated, this.length, addLen);
                /* Left shift of max bits will go to 0. An unsigned type set to
                * -1 will return the maximum possible size. However, we should
                *  have run out of memory well before we need to do this. Since
                *  this is the theoretical maximum total system memory we don't
                *  have a flag saying we can't grow any more because it should
                *  be impossible to get to this point. */
                this.allocated--;
                printf("if end %d < %d + %d\n", this.allocated, this.length, addLen);
            }
            printf("if after %d < %d + %d\n", this.allocated, this.length, addLen);
            if stopIter >= 150 {
                break;
            }
            stopIter++;
        }
        printf("After while\n");
        this.chars = realloc(this.chars, this.allocated);
        printf("After realloc\n");
        this.allocated = this.allocated + addLen;
        printf("After length re-set\n");
    }
}

function main(): Void {
    // var builder = StringBuilder.newFromString("hello world!");
    var builder = StringBuilder.newFromInt(479235634);
    builder.getLen();
    printf("%s\n", builder.toString());
    builder.appendString(" + ");
    builder.appendInt(63462182);
    // builder.ensureSpace(20: Int);
    // builder.getLen();
    builder.appendString(" fooooooooooooooooooooooooooo");
    builder.getLen();
    printf("%s\n", builder.toString());
}