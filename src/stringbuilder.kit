/**
 * An StringBuilder implementation in kit.
 * @author Tyler Bezera
 * @author Alex Poulsen
 */

import xs_Rounding;
include "math.h";

var _minSizePreDoubling: Int = 10;

/**
 * Not necessarily needed for the StringBuilder, but it's a useful function that works well for appending strings in a situation where a StringBuilder is not necessary
 */
function strAdd(one: CString, two: CString) {
    var out = malloc(one.length + two.length + 1);
    strcpy(out, one);
    strcat(out, two);
    return out;
}


struct StringBuilder {
    private var chars: Ptr[Char];
    private var length: Int;
    private var allocated: Int;

    public static function new(): StringBuilder {
        return struct Self {
            chars: *(malloc(20*sizeof(Char))): Ptr[Char],
            length: 0,
            allocated: 20
        };
    }

    public static function newFromString(initialize: CString, size: Int = 0): StringBuilder {
        var initSize: Int = _minSizePreDoubling;
        initSize = xs_MaxInt(initialize.length, initSize) * 2;
        initSize = xs_MaxInt(size, initSize);
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        strcpy(initChars, initialize);
        return struct Self {
            chars: initChars,
            length: initialize.length,
            allocated: initSize
        };
    }

    public static function newFromCharPtr(initialize: Ptr[Char], size: Int): StringBuilder {
        var initSize: Int = _minSizePreDoubling;
        initSize = xs_MaxInt(size, initSize) * 2;
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        strcpy(initChars, initialize);
        return struct Self {
            chars: initChars,
            length: size,
            allocated: initSize
        };
    }

    public static function newFromCharArray(initialize: CArray[Char], size: Int = 0): StringBuilder {
        var initSize: Int = _minSizePreDoubling;
        initSize = xs_MaxInt(initialize.length, initSize) * 2;
        initSize = xs_MaxInt(size, initSize);
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        strcpy(initChars, initialize);
        return struct Self {
            chars: initChars,
            length: initialize.length,
            allocated: initSize
        };
    }

    public static function newFromInt(initialize: Int, size: Int = 0): StringBuilder {
        var numSize: Int = xs_CeilToInt(log10(initialize: Float64));  // for numbers like 1000000000, it will report the length as one less than it is. this is fixed by multiplying the initSize by 2.
        var initSize: Int = _minSizePreDoubling;
        initSize = xs_MaxInt(numSize, initSize) * 2;
        initSize = xs_MaxInt(size, initSize);
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        sprintf(initChars,"%d", initialize);
        return struct Self {
            chars: initChars,
            length: numSize,
            allocated: initSize
        };
    }

    public static function newFromFloat(initialize: Float, size: Int = 0): StringBuilder {
        var initializeAboveDecimal: Float64 = xs_FloorToInt(initialize);
        var aboveDecimalSize: Int = xs_CeilToInt(log10(initializeAboveDecimal)) + 1;  // for numbers like 1000000000, it will report the length as one less than it is. this is fixed by multiplying the initSize by 2.
        var initSize: Int = _minSizePreDoubling;
        size = xs_MaxInt(aboveDecimalSize, size);
        initSize = (xs_MaxInt(size + 1, initSize) * 2) + 2;
        var initChars: Ptr[Char] = *(malloc(initSize*sizeof(Char))): Ptr[Char];
        printf("[%d]\n", size - aboveDecimalSize - 1);
        printf("[%d]\n", xs_MaxInt(size - aboveDecimalSize - 1, aboveDecimalSize));
        sprintf(initChars, "%.*f", xs_MaxInt(size - aboveDecimalSize - 1, aboveDecimalSize), initialize);
        return struct Self {
            chars: initChars,
            length: size,
            allocated: initSize
        };
    }

    public function printLengthAndAllocated(): Void {
        printf("length: %d\n", this.length);
        printf("allocated: %d\n", this.allocated);
    }

    public function toString(): CString {
        var out: CString = malloc((this.length + 1) * sizeof(CString));
        strcpy(out, this.chars);
        return out;
    }

    public function appendString(append: CString): Void {
        this.ensureSpace(append.length);
        strcat(this.chars, append);
        this.length += append.length;
    }

    public function appendInt(append: Int): Void {
        var numSize: Int = xs_CeilToInt(log10(append: Float64)) + 1;  // for numbers like 1000000000, log10 will report the length as one less than it is.
        var initChars: Ptr[Char] = *(malloc(numSize*sizeof(Char))): Ptr[Char];
        sprintf(initChars,"%d", append);
        this.ensureSpace(numSize);
        strcat(this.chars, initChars);
        this.length += numSize;
    }

    public function ensureSpace(addLen: Int): Void {
        // printf("Begin\n");
        if addLen == 0 {
            return;
        }
        // printf("After first if\n");
        if (this.allocated >= this.length + addLen + 1) {
            return;
        }
        var stopIter = 0;
        // printf("After second if\n");
        // printf("While begin\n");
        while (this.allocated < this.length + addLen + 1) {
            /* Doubling growth strategy. */
            // printf("begin %d < %d + %d\n", this.allocated, this.length, addLen);
            this.allocated <<= 1;
            if (this.allocated == 0) {
                // printf("if begin %d < %d + %d\n", this.allocated, this.length, addLen);
                /* Left shift of max bits will go to 0. An unsigned type set to
                * -1 will return the maximum possible size. However, we should
                *  have run out of memory well before we need to do this. Since
                *  this is the theoretical maximum total system memory we don't
                *  have a flag saying we can't grow any more because it should
                *  be impossible to get to this point. */
                this.allocated--;
                // printf("if end %d < %d + %d\n", this.allocated, this.length, addLen);
            }
            // printf("if after %d < %d + %d\n", this.allocated, this.length, addLen);
            if stopIter >= 150 {
                break;
            }
            stopIter++;
        }
        // printf("After while\n");
        this.chars = realloc(this.chars, this.allocated);
        // printf("After realloc\n");
        this.allocated = this.allocated + addLen;
        // printf("After length re-set\n");
    }
}

function main(): Void {
    for n in 0 ... 14 {
        // var builder = StringBuilder.newFromString("hello world!");
        // var builder = StringBuilder.newFromInt(479235634);
        var builder = StringBuilder.newFromFloat(2385.2463573_f64, n);
        var cp: Ptr[Char] = "abc 123";
        var ca: CArray[Char, 7];
        strcpy(ca, "lol hi");
        // var builder = StringBuilder.newFromCharPtr(cp, 7);
        // var builder = StringBuilder.newFromCharArray(ca);
        builder.appendString(" + ");
        builder.appendInt(63462182);
        builder.appendString(" fooooooooooooooooooooooooooo");
        printf("%s\n", builder.toString());
        builder.printLengthAndAllocated();
    }
}